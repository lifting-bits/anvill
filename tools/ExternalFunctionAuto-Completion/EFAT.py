#!/usr/bin/env python
#-------------------------------------------------------------------------------
# scripts/readelf.py
#
# A clone of 'readelf' in Python, based on the pyelftools library
#
# Eli Bendersky (eliben@gmail.com)
# This code is in the public domain
#
# above is the comments of the original pyreadelf project 
# this file is based of pyreadelf
#-------------------------------------------------------------------------------
import argparse
import time
import os, sys
import string
import re
import traceback
import itertools
import json
from collections import defaultdict
# Note: zip has different behaviour between Python 2.x and 3.x.
# - Using izip ensures compatibility.
try:
    from itertools import izip
except:
    izip = zip

# For running from development directory. It should take precedence over the
# installed pyelftools.
sys.path.insert(0, '.')


from elftools import __version__
from elftools.common.exceptions import ELFError
from elftools.common.utils import bytes2str, iterbytes
from elftools.elf.elffile import ELFFile
from elftools.elf.dynamic import DynamicSection, DynamicSegment
from elftools.elf.sections import (
    NoteSection, SymbolTableSection, SymbolTableIndexSection
)
from elftools.elf.gnuversions import (
    GNUVerSymSection, GNUVerDefSection,
    GNUVerNeedSection,
    )
from elftools.elf.relocation import RelocationSection
from elftools.elf.descriptions import (
    describe_ei_class, describe_e_machine,
    )


from elftools.dwarf.locationlists import LocationParser, LocationEntry, LocationViewPair, BaseAddressEntry as LocBaseAddressEntry, LocationListsPair
from elftools.dwarf.ranges import RangeEntry, BaseAddressEntry as RangeBaseAddressEntry, RangeListsPair


#A list of functions include from glibc
GLIBC_FUNCDECL_LIST = defaultdict(list)
#A list of functions include from glibc
GLIBCXX_FUNCDECL_LIST = defaultdict(list)

#the libc/libcxx_header must be the same with /dict/libc/libcxx.h
#things the libs below did't include all the libs,you can add new libs here. 

libcxx_header = """
#include<bits/stdc++.h>
"""


libc_header = """
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <iso646.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wchar.h>
#include <wctype.h>
#include <complex.h>
#include <fenv.h>
#include <inttypes.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdint.h>
#include <tgmath.h>
#include <uchar.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
"""


#the context used to write json file
json_header = """
{
    "Function" : [
"""
json_end = """
        ]
 }
"""

#the context used to write completion.cpp
cxx_header1 = """
  // mcsema ABI library, automatically generated by generate_abi_wrapper.py
  extern "C" {
"""

cxx_header2 = """
}

__attribute__((used)) void *__mcsema_externs[] = {
"""
#the context used to write completion.c
c_header = """

__attribute__((used)) void *__mcsema_externs[] = {
"""
cORcxx_end = """
};
"""



# a class which referemce the llvm/Demangle.h，which include the key consept of Demangled Func
class MangleNode:
    def __init__(self):
        self.MangledName = ""
        self.BaseName = ""
        self.DeclContextName = ""
        self.Parameters = ""
        self.FunctionName = ""
        self.EntireName = ""
        self.ReturnType = ""
        self.hasFunctionQualifiers =False
        self.isCtorOrDtor =False
        self.isFunction =False
        self.isData =False
        self.isSpecialName =False




class ReadElf(object):
    """ display_* methods are used to emit output into the output stream
    """
    def __init__(self, file, output):
        """ file:
                stream object with the ELF file to read

            output:
                output stream to write to
        """
        self.elffile = ELFFile(file)
        self.output = output

        # Lazily initialized if a debug dump is requested
        self._dwarfinfo = None

        self._versioninfo = None

        self._shndx_sections = None


    # By modifying this function, the automation from parsing the elf file symbol table to 
    # generating supplementary function definitions is realized
    def demangle_symbol_tables_and_generate_complement_functions(self):
        #Anomaly detection that preserves the integrity of the symbol table in the original script
        self._init_versioninfo()

        symbol_tables = [(idx, s) for idx, s in enumerate(self.elffile.iter_sections())
                         if isinstance(s, SymbolTableSection)]

        if not symbol_tables and self.elffile.num_sections() == 0:
            self._emitline('')
            self._emitline('Dynamic symbol information is not available for'
                           ' displaying symbols.')
        GCCLib_path = os.environ['LIFT_GCC_LIB_PATH']
        cpp_flag=False
        continue_flag=False
        #an elf file has many sections in smytalbes,like '.dynsym','.symtab',
        # in order to cover most of the extern func，we loop all the sections.
        for section_index, section in symbol_tables:
            if not isinstance(section, SymbolTableSection):
                continue

            if section['sh_entsize'] == 0:
                self._emitline("\nSymbol table '%s' has a sh_entsize of zero!" % (
                    section.name))
                continue

            self._emitline("\nSymbol table '%s' contains %d %s:" % (
                section.name,
                section.num_symbols(),
                'entry' if section.num_symbols() == 1 else 'entries'))
            
            #This loop is implemented for the main function, which reads the symbol table and processes
            for nsym, symbol in enumerate(section.iter_symbols()):
                #Read the symbol table, only take TYPE=FUNC, Ndx=UND
                if (symbol['st_info'] ['type']== 'STT_FUNC' and
                    symbol['st_shndx'] == 'SHN_UNDEF'):
                    # There is no clear sign in the elf file that the program is a C++ program. 
                    # Here we judge whether the program is a C++ program by 
                    # checking whether the Name Mangling function exists in the symbol table.
                    if cpp_flag==False:
                        if symbol.name [0:2]=="_Z":
                            cpp_flag=True
                    #The elf file on the x86 platform will have a suffix of ***@@GLIBCXX_3.4 
                    # after the thing taken out of .symtab (one less @ on Arm)
                    libCorCXXverson_obj=re.search('@+GLIBC[A-Za-z]*_[0-9,.]+',symbol.name)
                    if libCorCXXverson_obj !=None:
                        #For the time being, only those with the GLIBC*** logo are processed.
                        funcName=symbol.name[0:libCorCXXverson_obj.regs[0][0]]
                        libVersionName=symbol.name[libCorCXXverson_obj.regs[0][0]: ]
                        if re.search('GLIBCXX',libVersionName):
                            key=funcName
                            GLIBCXX_FUNCDECL_LIST[key].append("1")
                            continue_flag=True
                        else:
                            key=funcName
                            GLIBC_FUNCDECL_LIST[key].append("1")
                            continue_flag=True
        
        #If the program to be translated is a C++ program and there are extern_functions after Name_Mangling
        if  continue_flag==True:
            if cpp_flag and len(GLIBCXX_FUNCDECL_LIST)!=0:
                DemangleToolsPath = os.path.dirname(os.path.abspath(__file__))+"/../DemanglingTools/"
                outfile=DemangleToolsPath+"in.json"
                #First hand over the recognized mangled function to the 
                #C++ internal interface of llvm for processing
                write_json_file(outfile)

                print("start to write in.json (if 0 success) ")
                time.sleep(2)
                print(os.system("cat "+outfile))
                DemangleToolsCommand = DemangleToolsPath+"Demanglingtools"
                print(os.chdir("../DemanglingTools/"))
                print(os.system(DemangleToolsCommand))
                #Read the processed result
                inputjsonfile=DemangleToolsPath+"out.json"
                print(os.chdir("../pyelftools/"))
                #print(os.system("cat "+inputjsonfile))
                with open(inputjsonfile, 'r') as json_file:
                    json_data = json.load(json_file)

                #write the Complement.c/cpp
                abioutfile=os.path.dirname(os.path.abspath(__file__))+"/../Result/"
                write_cxx_abi_file(abioutfile,json_data,GCCLib_path)
            else:
                abioutfile=os.path.dirname(os.path.abspath(__file__))+"/../Result/"
                write_c_abi_file(abioutfile,GCCLib_path)

        else:
            print("There was a problem parsing the symbol table. end of program")  
            sys.exit()  
        
        #Complement.c/cpp has been generated so far, 
        #and finally the corresponding supplementary LLVMIR is generated
        if cpp_flag == True:
            compiler="clang++"
            liftingFile=abioutfile+"complement.cpp"
        else:
            compiler="clang"
            liftingFile=abioutfile+"complement.c"

        LiftCommand=compiler+ " -emit-llvm  -c  "+ liftingFile+ " -o" +abioutfile+"liftedComplement.bc"
        
        
        print(os.system(LiftCommand))
        LLVMdisCommand="llvm-dis " +abioutfile+"liftedComplement.bc"
        print(os.system(LLVMdisCommand))    




            
                


    
    
    def _init_versioninfo(self):
        """ Search and initialize informations about version related sections
            and the kind of versioning used (GNU or Solaris).
        """
        if self._versioninfo is not None:
            return

        self._versioninfo = {'versym': None, 'verdef': None,
                             'verneed': None, 'type': None}

        for section in self.elffile.iter_sections():
            if isinstance(section, GNUVerSymSection):
                self._versioninfo['versym'] = section
            elif isinstance(section, GNUVerDefSection):
                self._versioninfo['verdef'] = section
            elif isinstance(section, GNUVerNeedSection):
                self._versioninfo['verneed'] = section
            elif isinstance(section, DynamicSection):
                for tag in section.iter_tags():
                    if tag['d_tag'] == 'DT_VERSYM':
                        self._versioninfo['type'] = 'GNU'
                        break

        if not self._versioninfo['type'] and (
                self._versioninfo['verneed'] or self._versioninfo['verdef']):
            self._versioninfo['type'] = 'Solaris'

    def _emit(self, s=''):
        """ Emit an object to output
        """
        self.output.write(str(s))

    def _emitline(self, s=''):
        """ Emit an object to output, followed by a newline
        """
        self.output.write(str(s).rstrip() + '\n')


SCRIPT_DESCRIPTION = 'Display information about the contents of ELF format files'
VERSION_STRING = '%%(prog)s: based on pyelftools %s' % __version__


def main(stream=None):
    # parse the command-line arguments and invoke ReadElf
    argparser = argparse.ArgumentParser(
            usage='usage: %(prog)s [options] <elf-file>',
            description=SCRIPT_DESCRIPTION,
            add_help=False, # -h is a real option of readelf
            prog='readelf.py')
    argparser.add_argument('file',
            nargs='?', default=None,
            help='ELF file to parse')
    argparser.add_argument('-v', '--version',
            action='version', version=VERSION_STRING)
    argparser.add_argument('-H', '--help',
            action='store_true', dest='help',
            help='Display this information')
    argparser.add_argument('-h', '--file-header',
            action='store_true', dest='show_file_header',
            help='Display the ELF file header')
    argparser.add_argument('-l', '--program-headers', '--segments',
            action='store_true', dest='show_program_header',
            help='Display the program headers')
    argparser.add_argument('-S', '--section-headers', '--sections',
            action='store_true', dest='show_section_header',
            help="Display the sections' headers")
    argparser.add_argument('-e', '--headers',
            action='store_true', dest='show_all_headers',
            help='Equivalent to: -h -l -S')
    #Call the method that generates the supplementary function by registering a new parameter
    argparser.add_argument('-complement', 
            action='store_true', dest='demangle_and_complement_symbols',
            help='Demangle the symbol table and generate complement functions for mcsema')    


    args = argparser.parse_args()

    if args.help or not args.file:
        argparser.print_help()
        sys.exit(0)

    if args.show_all_headers:
        do_file_header = do_section_header = do_program_header = True
    else:
        do_file_header = args.show_file_header
        do_section_header = args.show_section_header
        do_program_header = args.show_program_header

    with open(args.file, 'rb') as file:
        try:
            readelf = ReadElf(file, stream or sys.stdout)
            if do_file_header:
                readelf.display_file_header()
            if do_section_header:
                readelf.display_section_headers(
                        show_heading=not do_file_header)
            if do_program_header:
                readelf.display_program_headers(
                        show_heading=not do_file_header)
            #Add the corresponding registration function call of -complement    
            if args.demangle_and_complement_symbols:
                readelf.demangle_symbol_tables_and_generate_complement_functions()

        except ELFError as ex:
            sys.stdout.flush()
            sys.stderr.write('ELF error: %s\n' % ex)
            if args.show_traceback:
                traceback.print_exc()
            sys.exit(1)


def write_cxx_abi_file(outfile,jsonDict,allDictPath):
    """ Generate ABI library source for the c headers; 
    """
    # generate the abi lib cxx file
    dictPath=allDictPath
    outfile=outfile+"complement.cpp"
    with open(outfile, "w") as s:
        #Write the include header file first
        s.write(libcxx_header)
            
        s.write(cxx_header1)
        #The first layer of loops traverses FUNCDECL_LIST
        for value in jsonDict["Function"]:
            value["canBeComplement"]=False
            if value.get("ReturnType") != "":
                s.write("{0} {1} {2};".format(value.get("ReturnType"),value.get("MangledName"),value.get("Parameters")))
                s.write("\n")
                value["canBeComplement"]=True
            elif value.get("isCtorOrDtor") ==True:
                s.write("void {1} {2};".format(value.get("ReturnType"),value.get("MangledName"),value.get("Parameters")))
                s.write("\n")
                value["canBeComplement"]=True
            elif re.search('std::[A-Za-z]+',value.get("DeclContextName")):
                s.write("{0} {1} {2};".format(value.get("DeclContextName"),value.get("MangledName"),value.get("Parameters")))
                s.write("\n")
                value["canBeComplement"]=True
            else:
                sys.path.append(dictPath)
                print(dictPath)
                from allcxxdict import dict
                CXXSearchDict=dict.dictionary
                if CXXSearchDict.get(value.get("BaseName"))!=None:
                    if isinstance(CXXSearchDict.get(value.get("BaseName")),list):
                        for funcs in CXXSearchDict.get(value.get("BaseName")):
                            if funcs[1]==value.get("Parameters"):
                                s.write("{0} {1} {2};".format(funcs[0],value.get("MangledName"),value.get("Parameters")))
                                s.write("\n")
                                value["canBeComplement"]=True    
                    else:
                        s.write("{0} {1} {2};".format(CXXSearchDict.get(value.get("BaseName")),value.get("MangledName"),value.get("Parameters")))
                        s.write("\n")
                        value["canBeComplement"]=True
                else:
                    print(value.get("MangledName"))
                    print(" unable to supplement\n")
        s.write(cxx_header2)


        for value in jsonDict["Function"]:
            if value["canBeComplement"]==True:
                s.write("(void *) {0},".format(value["MangledName"]))
                s.write("\n")
        for key in GLIBC_FUNCDECL_LIST.keys():
            sys.path.append(dictPath)
            print(dictPath)
            from allcxxdict import dict
            CXXSearchDict=dict.dictionary
            if CXXSearchDict.get(key)!=None:
                if isinstance(CXXSearchDict.get(key),list):
                    print(key)
                    print(" unable to supplement\n")
                else:
                    s.write("(void *) {0},".format(key))
                    s.write("\n")
            else:
                print(key)
                print(" unable to supplement\n")


        s.write(cORcxx_end)

def write_c_abi_file(outfile,allDictPath):
    """ Generate ABI library source for the c headers; 
    """
    # generate the abi lib cc file
    outfile=outfile+"complement.c"
    dictPath=allDictPath
    with open(outfile, "w") as s:
        #Write the include header file first
        s.write(libc_header)

        s.write(c_header)
        for key in GLIBC_FUNCDECL_LIST.keys():
            sys.path.append(dictPath)
            from allcdict import dict
            CSearchDict=dict.dictionary
            if CSearchDict.get(key)!=None:
                s.write("(void *) {0},".format(key))
                s.write("\n")
            else:
                print(key)
                print(" unable to supplement\n")


        s.write(cORcxx_end)





def write_json_file(outfile):
    """ Generate json library source for the Demangling tools; 
    """
    with open(outfile, "w") as s:
        s.truncate()
        s.write(json_header)
        #遍历GLIBCXX_FUNCDECL_LIST
        i=0
        num=len(GLIBCXX_FUNCDECL_LIST)
        for key in GLIBCXX_FUNCDECL_LIST.keys():
                str="{ \"name\":\""+key+"\" }"
                s.write(str)
                i=i+1
                if i!=num:
                    s.write(",")
                s.write("\n")
        s.write(json_end)

    



def profile_main():
    # Run 'main' redirecting its output to readelfout.txt
    # Saves profiling information in readelf.profile
    PROFFILE = 'readelf.profile'
    import cProfile
    cProfile.run('main(open("readelfout.txt", "w"))', PROFFILE)

    # Dig in some profiling stats
    import pstats
    p = pstats.Stats(PROFFILE)
    p.sort_stats('cumulative').print_stats(25)


#-------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
    #profile_main()
